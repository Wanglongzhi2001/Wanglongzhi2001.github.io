<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解反射</title>
      <link href="/2022/12/27/xiang-jie-fan-she/"/>
      <url>/2022/12/27/xiang-jie-fan-she/</url>
      
        <content type="html"><![CDATA[<p>在之前的学习中，对反射总是一知半解，之前对反射的作用大概就停留在获取、设置结构体tag的值、获取结构体字段的值、属性，以及一些json的序列化和反序列化貌似也是通过反射做的？，今天花了几个小时详细的了解了一番golang中的反射，在此记录一下！</p><h2 id="反射三原则"><a href="#反射三原则" class="headerlink" title="反射三原则"></a>反射三原则</h2><p>在使用反射之前,此文<a href="https://go.dev/blog/laws-of-reflection">The Laws of Reflection</a>必读.网上中文翻译版本不少,可以搜索阅读.<br><br>三原则：</p><ul><li>Reflection goes from interface value to reflection object</li><li>Reflection goes from reflection object to interface value</li><li>To modify a reflection object, the value must be settable</li></ul><p>在三原则中,有两个关键词 interface value 与 reflection object.有点难理解,画张图可能您就懂了.<br></p><p><img src="/../assets/reflect/reflect-pic.jpg" alt="反射" title="反射"></p><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。使用反射，我们需要导入reflect包</p><ul><li><p>获取类型信息(static type)：reflect.TypeOf，是静态的</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import ("fmt""reflect")func main() {var x float64 = 3.4fmt.Println("type:", reflect.TypeOf(x))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">type: float64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们查看<code>reflect.TypeOf</code>源码，会发现其返回值是<code>Type</code>类型，这验证了我们上面所说的Type和Value</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">// TypeOf returns the reflection Type that represents the dynamic type of i.// If i is a nil interface value, TypeOf returns nil.func TypeOf(i any) Type {eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))return toType(eface.typ)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取反射的种类Kind</p></li></ul><p>什么叫Kind，在Golang中如果你定义<code>var a int32 = 5</code>，那么显然a是int32类型的，或者我们叫其<code>static type</code>为int，但是如果你定义了自定义类型</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">type Myint int32var a Myint = 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么a的<code>static type</code>是Myint也就是你显式声明的类型，而a的<code>underly type</code>是int32，也就是说a的潜在类型是int，而<code>Kind</code>方法返回的是<code>underly type</code>!</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import ("fmt""reflect")func main() {type Myint int32var A Myint = 5typeofA := reflect.TypeOf(A)fmt.Printf("static type: %v \n", typeofA.Name())fmt.Printf("underly type: %v \n", typeofA.Kind())}/* 输出结果static type: Myintunderly type: int32 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相同的，对于结构体我们这么干得到的结果也是如我们所预期的那样</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {type A struct{}a := A{}typeofa := reflect.TypeOf(a)fmt.Printf("static type: %v \n", typeofa.Name())fmt.Printf("underly type: %v \n", typeofa.Kind())}/* 输出结果static type: Aunderly type: struct */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>获取值信息：reflect.ValueOf，是动态的</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {var x float64 = 3.4valueofX := reflect.ValueOf(x)fmt.Println("value:", valueofX)fmt.Println("value:", valueofX.String())}/* 输出结果value: 3.4value: &lt;float64 Value&gt;*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们我们显式调用String方法，因为默认情况下，fmt包会挖掘到reflect.Value，以显示内部的具体值。而String方法不会</p></li><li><p>修改值信息</p></li></ul><p>在反射中修改值信息是通过<code>SetFloat</code>、<code>SetInt</code>方法(具体方法根据具体类型而定)，但是有一些坑需要注意<br>如果我们直接使用<code>SetFloat</code>方法</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {var x float64 = 3.4v := reflect.ValueOf(x)v.SetFloat(7.1) // Error: will panic.}/* 输出结果panic: reflect: reflect.Value.SetFloat using unaddressable value*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根本原因在于，我们传入x是对x值拷贝，因此你对拷贝的值进行了修改而你以为对原来的x进行了修改，导致你对拷贝的值修改过后却没有用到他，Go当然不会允许这样的事情发生，因此panic！<br><br>我们可以通过<code>CanSet</code>方法来查看能否修改</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var x float64 = 3.4v := reflect.ValueOf(x)fmt.Println("settability of v:", v.CanSet())/* 结果settability of v: false*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确做法：传入x的地址，并调用Elem方法解引用！</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var x float64 = 3.4p := reflect.ValueOf(&amp;x) // Note: take the address of x.v := p.Elem()v.SetFloat(6.9)fmt.Println("settability of v:", v.CanSet())fmt.Println("value of x: ", x)/* 输出结果settability of v: truevalue of x:  6.9*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们修改值信息必须知道对应的类型来调用对应的方法，因此我们通常可以配和使用switch来实现</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">//反射修改值func reflect_set_value(a interface{}) {    v := reflect.ValueOf(a)    k := v.Kind()    switch k {    case reflect.Float64:        // 反射修改值        v.SetFloat(6.9)        fmt.Println("a is ", v.Float())    case reflect.Ptr:        // Elem()获取地址指向的值        v.Elem().SetFloat(7.9)        fmt.Println("case:", v.Elem().Float())        // 地址        fmt.Println(v.Pointer())    }}func main() {    var x float64 = 3.4    // 反射认为下面是指针类型，不是float类型    reflect_set_value(&amp;x)    fmt.Println("main:", x)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反射与结构体"><a href="#反射与结构体" class="headerlink" title="反射与结构体"></a>反射与结构体</h2><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。</p><h3 id="查看结构体类型、字段、方法"><a href="#查看结构体类型、字段、方法" class="headerlink" title="查看结构体类型、字段、方法"></a>查看结构体类型、字段、方法</h3><p>我们可以根据<code>NumField</code>方法得到结构体有多少个字从而进行遍历，通过<code>Field</code>方法得到具体的某个字段，通过<code>NUmMethod</code>得到结构体有多少个方法，通过<code>Method</code>方法得到具体的某个方法</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">// 定义结构体type User struct {Id   intName stringAge  int}// 绑方法func (u User) Hello() {fmt.Println("Hello")}// 传入interface{}func Poni(o interface{}) {t := reflect.TypeOf(o)fmt.Println("类型：", t)fmt.Println("字符串类型：", t.Name())// 获取值v := reflect.ValueOf(o)fmt.Println(v)// 可以获取所有属性// 获取结构体字段个数：t.NumField()for i := 0; i &lt; t.NumField(); i++ {// 取每个字段f := t.Field(i)fmt.Printf("%s : %v", f.Name, f.Type)// 获取字段的值信息// Interface()：获取字段对应的值val := v.Field(i).Interface()fmt.Println("val :", val)}fmt.Println("=================方法====================")for i := 0; i &lt; t.NumMethod(); i++ {m := t.Method(i)fmt.Println(m.Name)fmt.Println(m.Type)}}func main() {u := User{1, "zs", 20}Poni(u)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未完待续…</p><blockquote><p><a href="https://go.dev/blog/laws-of-reflection">The Laws of Reflection</a><br><br><a href="https://www.topgoer.cn/docs/golang/chapter11-12">反射(地鼠文档)</a><br><br><a href="https://pkg.go.dev/reflect@go1.19.4#pkg-overview">reflect(go官方文档)</a><br><br><a href="https://zhuanlan.zhihu.com/p/411313885">一篇带你全面掌握go反射的用法</a><br><br><a href="http://c.biancheng.net/view/4407.html">Go语言反射（reflection）简述</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建自己的个人博客</title>
      <link href="/2022/12/23/hexo-da-jian-zi-ji-de-ge-ren-bo-ke/"/>
      <url>/2022/12/23/hexo-da-jian-zi-ji-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo下载"><a href="#hexo下载" class="headerlink" title="hexo下载"></a>hexo下载</h2><h3 id="node-js和cnpm下载"><a href="#node-js和cnpm下载" class="headerlink" title="node.js和cnpm下载"></a>node.js和cnpm下载</h3><p>因为hexo是依赖于node.js的，因此我们需要先下载node.js(<a href="nodejs.org">node.js下载地址</a>)。<br>node.js安装过程就一路next即可<br><br>我们使用<code>node -v</code>来查看node.js是否安装成功</p><p><img src="/../assets/nodejs-v.png"></p><p>下载完node.js我们再来进行一下简单的配置，具体可以参见<a href="https://zhuanlan.zhihu.com/p/442215189">这篇博客</a></p><p>下载完node.js一般会自动帮你把npm下载好同样的我们使用<code>npm-v</code>查看是否安装<br><img src="/../assets/npm-v.png"></p><p>然后我们接着用淘宝源下载cnmp：</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry=https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样用<code>cnpm -v</code>查看是否安装成功<br><img src="/../assets/cnpm-v.png"></p><h3 id="hexo下载-1"><a href="#hexo下载-1" class="headerlink" title="hexo下载"></a>hexo下载</h3><p>终于到了下载hexo了，执行下面命令下载：</p><pre class="line-numbers language-none"><code class="language-none">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看是否安装成功：</p><p><img src="/../assets/hexo-v.png"></p><p>接下来我们创建一个空目录叫Blog(里面会装所有我们的博客内容、配置、样式等)，我这里在D盘创建了。然后跳转到这个目录，执行<code>hexo init</code></p><p><img src="/../assets/hexo-init.png"></p><p>然后目录里就会自动生成这么多文件:</p><p><img src="/../assets/hexo-init-dir.png"></p><p>接下来我们执行<code>hexo s</code>表示start，</p><p><img src="/../assets/hexo-s.png"></p><p>显示运行在4000端口，那我们打开4000端口，会出现这样一个系统默认自带的一个博客页面</p><p><img src="/../assets/hexo-s-4000.png"></p><p>也可以看到里面有四条简单的入门指令</p><h2 id="hexo新建文章"><a href="#hexo新建文章" class="headerlink" title="hexo新建文章"></a>hexo新建文章</h2><p>接下来到了我们的重点，我们使用<code>hexo n</code>(hexo new的简写) 来新建一篇博客</p><p><img src="/../assets/hexo-n.png"></p><p>接下来我们跳转到<code>source\_posts</code>目录下可以看到<code>我的第一篇博客.md</code><br>接下来，我们就可以打开这个md文件(Vscode或者记事本等等，linux还可以用vim)进行编辑来达到写博客的效果。<br><br>编写完博客后我们分别执行<code>hexo clean</code>删除缓存文件和<code>hexo generate</code>生成静态文件</p><p><img src="/../assets/hexo-clean-generate.png"></p><p>然后我们再执行<code>hexo s</code>在本地看看效果吧：<br>不出意外，你应该可以看到你新建的那篇博客！</p><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>首先我们先登录我们的github新建一个名为<code>username.github.io</code>的仓库(其中username为你自己的用户名)，千万注意这个仓库名只能是这个，一个字符都不能错！！！<br></p><p>创建完后当前仓库还是空的，我们先下载一个hexo-deployer-git包:</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进行一些关键配置：<br>进入Blog目录找到_config.yml并打开，将type后面填入git(单引号别删，mac系统貌似本来就没有单引号)，然后在下面添加两行repo和branch，repo填入自己刚刚创建好的那个github仓库地址(.git后缀)，branch就填master就好(注意冒号后面加空格哦)</p><p><img src="/../assets/hexo-config.png"></p><p>配置好后直接<code>hexo d</code>就开始部署了！（如果你之前没对github做什么配置的话应该是要输入github用户名和密码的）<br></p><p>部署好了之后，打开刚才新建的仓库，会发现仓库有东西了！</p><p><img src="/../assets/hexo-d-repo.png"></p><p>这时我们打开<code>username.github.io</code>(其中username为你的github用户名)，你会发现你的博客出现了！（可能没那么快，等个半分钟左右就会出现），至此已经完成了搭建个人笔记网站及部署！</p><h2 id="博客样式更改"><a href="#博客样式更改" class="headerlink" title="博客样式更改"></a>博客样式更改</h2><p>克隆<code>https://github.com/litten/hexo-theme-yilia</code>这个仓库到你的Blog目录下的themes目录下，名称可以取为yilia</p><p><img src="/../assets/yilia-down.png"></p><p>然后再打开Blog下的<code>_config.yml</code>将其中的theme后的内容改成yilia，然后我们继续<code>hexo clean'和'hexo generate</code>和<code>hexo d</code>在刷新我们的个人博客即可出现更新后的样式！</p><p>详细配置修改：<br>进入yilia目录，打开其中的<code>_config.yml</code>修改其中的配置！比如我要上传自己的头像，我就在public目录下创建assets目录再创建img目录，其中放入我的头像，然后在yilia目录里的_config.yml文件里先将我的根目录改为：<code>root: /themes/yilia/source/</code>，再将头像url改为：<code>avatar: /assets/img/me.jpg</code></p><p><img src="/../assets/img_upload.png"></p><p>然后再重复<code>hexo clean'和'hexo generate</code>和<code>hexo d</code>在刷新我们的个人博客即可出现更新后的样式！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=6f8003c7f384d9ec853a735c71e66571">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 博客相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/23/hello-world/"/>
      <url>/2022/12/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
