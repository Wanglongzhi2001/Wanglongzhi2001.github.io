<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/2022/12/30/rabbitmq-ru-men/"/>
      <url>/2022/12/30/rabbitmq-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows下RabbitMQ安装"><a href="#Windows下RabbitMQ安装" class="headerlink" title="Windows下RabbitMQ安装"></a>Windows下RabbitMQ安装</h1><h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><ul><li><p>下载安装<br><br>原因：RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang<br><br>下载地址：<a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a><br><img src="/../assets/RabbitMQ/erlang_install.png"><br>安装过程一路next，不过安装路径自选</p></li><li><p>环境变量<br><br>  此电脑–&gt;鼠标右键“属性”–&gt;高级系统设置–&gt;环境变量–&gt;“新建”系统环境变量，变量名：ERLANG_HOME<br>  变量值就是刚才erlang的安装地址，点击确定。<br>  <img src="/../assets/RabbitMQ/env_var1.png"><br>  然后双击系统变量path，点击“新建”，将%ERLANG_HOME%\bin加入到path中。<br>  <img src="/../assets/RabbitMQ/env_var2.png"></p><p>  最后在cmd输入<code>erl</code>查看是否安装成功</p><p>  <img src="/../assets/RabbitMQ/erl_install_cmd.png"></p></li></ul><h2 id="下载并安装RabbitMQ"><a href="#下载并安装RabbitMQ" class="headerlink" title="下载并安装RabbitMQ"></a>下载并安装RabbitMQ</h2><ul><li><p>下载地址：<a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a></p><p>  <img src="/../assets/RabbitMQ/rabbitmq_install.png"><br>  安装过程也是一路next，安装路径自己改</p></li><li><p>环境变量<br><br>  添加系统变量<br>  <img src="/../assets/RabbitMQ/rabbi_env_var1.png"></p><p>  将系统变量\sbin添加到path中</p><p>  <img src="/../assets/RabbitMQ/rabbi_env_var2.png"></p></li></ul><h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><p>进入sbin目录，在此目录下打开cmd，输入<code>rabbitmq-plugins enable rabbitmq_management</code>，然后再输入<code>rabbitmq-server.bat</code>运行<br><br>注：我在此处运行失败，我是参考了<a href="https://blog.csdn.net/jiankang66/article/details/90384050">这篇文章</a>的方法才成功，以后可以使用<code>net start rabbitmq</code>来开启服务</p><p>打开服务后，打开<code>http://localhost:15672</code>，账号密码均为<code>guest</code>，即可进入管理页面</p><p><img src="/../assets/RabbitMQ/manage_page.png"></p><p>同样的，我们可以使用<code>net stop rabbitmq</code>来停止服务，此时再打开15672端口就打不开了</p><h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><h2 id="基本命令行使用"><a href="#基本命令行使用" class="headerlink" title="基本命令行使用"></a>基本命令行使用</h2><p>windows在rabbitmq command prompt中使用<code>rabbitmq-plugins list</code>命令即可查看当前已安装的插件<br>空的中括号表示没有安装的插件，中括号中的E或e表示以安装的插件<br><img src="/../assets/RabbitMQ/rabbitmq-plugins_list.png"></p><p>往下滑会看到一个rabbitmq_tracing插件并没有安装，我们可以通过<code>rabbitmq-plugins enable rabbitmq_tracing</code>的方式安装这个插件，安装完后如果你再使用<code>rabbitmq-plugins list</code>命令会发现这个插件前面中括号里多了E表示已安装 同样的要卸载这个插件只需使用<code>rabbitmq-plugins disable rabbitmq_tracing</code></p><h2 id="管理页面基本查看"><a href="#管理页面基本查看" class="headerlink" title="管理页面基本查看"></a>管理页面基本查看</h2><p>打开15672端口登陆后，可以看到首页显示了一些基本信息，其中点击红框就可以查看节点的具体信息</p><p><img src="/../assets/RabbitMQ/web_page1.png"></p><p>上方的connections框点击进去会显示一些连接信息，Channels页面会显示一些隧道信息，Queues页面会显示我们的队列信息，Admin界面会显示我们的用户信息</p><p><img src="/../assets/RabbitMQ/Admin_page.png"></p><p>点击红框可以添加用户(不过要注意权限问题)，紫框是管理我们的虚拟机</p><h2 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h2><ul><li>VirtualHost<br><br>介绍具体概念之前，先让我们在管理界面上新建一个VirtualHost名为test(后面简记为vHost)方便理解<br><img src="/../assets/RabbitMQ/add_vHost.png"><br>通过输入vHost名称再进行添加可以看到上方界面多了个vHost<br><br><img src="/../assets/RabbitMQ/add_vHost2.png"><br>并且再点击Admin可以看到我们的guest用户多了个test这个vHost(之前只有/这一个vHost)<br>再让我们新建一个用户testuser(这里我们指定这个用户为管理员)<br><img src="/../assets/RabbitMQ/add_user.png"><br>添加完用户后我们可以发现应如下图所示(我的已经绑定了所以就不用我的图了)初始没有绑定vHost<br><img src="/../assets/RabbitMQ/add_user2.png"><br>  我们按下图所示点击按钮并绑定我们的vHost为test<br><img src="/../assets/RabbitMQ/add_user3.png"><br>  这样就可以看到我们的不同用户所对应的vHost了<br><img src="/../assets/RabbitMQ/add_user4.png"><br>现在，让我们说说vHost的作用：vhost起数据隔离的作用，刚才的testuser用户赋给了test这个vhost，那么不管他新建连接还是发送queues都只能在这个vhost中执行，不会到/这个vhost上<br><img src="/../assets/RabbitMQ/add_user5.png"><br>可以看到，新建vhost后，exchanges自动帮我们创建了这些exchanges来帮我们区分哪些。所以vhost是用来区分队列和隔离账号，这样通过vhost进行逻辑隔离可以用来隔开我们的开发、测试环境exchanges用于哪些vhost</li><li>Connection<br><br>RabbitMQ监听进程后会在Connections出进行展示</li><li>Exchange<br><br>叫做交换机，用作中转，当生产者生产消息时会首先进入交换机，根据交换机指定的规则，绑定对应的key，把所有的消息通过交换机发送到对应的key</li><li>Channel<br><br>就是刚才的connection下会建立许多channel进行通信</li><li>Queue<br><br>先在此处新建一个队列，就可以在界面中看到我们新建的队列<br><img src="/../assets/RabbitMQ/queue.png"><br>队列的作用：绑定交换机、接收消息，只要没有消费者就一直把消息存储到队列里面</li><li>Binding<br><br>就是把刚才的队列绑定到交换机里，通过不同方式的绑定可以实现不同的工作模式</li></ul><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发秒杀系统项目</title>
      <link href="/2022/12/30/gao-bing-fa-miao-sha-xi-tong-xiang-mu/"/>
      <url>/2022/12/30/gao-bing-fa-miao-sha-xi-tong-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h1><ul><li>前台页面展示</li><li>用户登录注册</li><li>后台订单管理</li></ul><h1 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h1><h2 id="系统需求分析"><a href="#系统需求分析" class="headerlink" title="系统需求分析"></a>系统需求分析</h2><ul><li>前端页面需要承载大流量</li><li>在大并发状态下要解决超卖问题</li><li>后端接口需要满足横向扩展</li></ul><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="/../assets/miaosha_project/jiagou.png"></p><ol><li>把页面和所有静态资源放到CDN上做第一道屏障来拦截大量的访问，CDN上有一个静态回源(根据实际使用，压力很小)</li><li>通过CDN，动态请求进入流量负载均衡器(采用阿里云的SLB)</li><li>流量拦截系统保护我们的系统和接口，可通过其进行一系列的安全设计</li><li>通过流量拦截系统后，剩下的访问会进入我们的GO服务器集群(负责我们的逻辑需求)</li><li>抢到商品后，将商品放入RabbitMQ消息队列中</li><li>通过RabbitMQ进入消费端消费我们的消息</li><li>最终将商品的状态放入MySQL中</li></ol><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>net/http包入门</title>
      <link href="/2022/12/28/net-http-bao-ru-men/"/>
      <url>/2022/12/28/net-http-bao-ru-men/</url>
      
        <content type="html"><![CDATA[<p>在学习websocket时发现源码里用到很多net/http包，导致看的有点费力。因为之前一直用的gin框架，所以没怎么看net/http包，但是想到毕竟是内置的包，不仅很多别的包会用到，而且自己要实现一些小功能的话肯定也是优先会使用net/http包，因此在此学习下net/http包</p><p>首先，net/http包提供了服务端和客户端的实现，下面让我们看看服务端和客户端的相关函数示例</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>先看看下面这段代码</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import ("fmt""net/http")func main() {//http://127.0.0.1:8000/go// 单独写回调函数http.HandleFunc("/go", myHandler)//http.HandleFunc("/ungo",myHandler2 )// addr：监听的地址// handler：回调函数http.ListenAndServe("127.0.0.1:8000", nil)}// handler函数func myHandler(w http.ResponseWriter, r *http.Request) {fmt.Println(r.RemoteAddr, "连接成功")// 请求方式：GET POST DELETE PUT UPDATEfmt.Println("method:", r.Method)// /gofmt.Println("url:", r.URL.Path)fmt.Println("header:", r.Header)fmt.Println("body:", r.Body)// 回复w.Write([]byte("来自我的回复"))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要提的是<code>http.HandleFunc</code>函数，毫无疑问，作为服务端首先要写一个路由然后为这个路由绑定相关的处理函数。这个函数就相当于gin框架中的<code>r.GET</code>或者<code>r.POST</code>方法，但是这里的服务端貌似不能为路由指定GET或者POST等方式，只能在客户端指定GET或者POST的访问方式<br><br>对于传入的路由的处理函数，我们看到下面的myHandler就能看到，需要传入<code>http.ResponseWriter</code>和<code>*http.Request</code>两种类型的变量。<br><br><code>http.ResponseWriter</code>是用来构造响应的，也就是说用它来设置你这个路由函数要输出什么怎么输出<br><br><code>*http.Request</code>是请求表示由服务器接收或由客户端发送的HTTP请求，由它我们能得到请求的ip地址，请求访问的路由的路径等等，也就是说这个接口代表了你输入的信息<br><br>最后，<code>http.ListenAndServe</code>用来启动我们的HTTP服务端！第一个参数需要传入TCP网络地址，第二个参数传入对应的处理函数（通常为nil从而使用默认的DefaultServeMux）</p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>同样的，看个简单的示例，对这个示例进行解读</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import (    "fmt"    "io"    "net/http")func main() {    //resp, _ := http.Get("http://127.0.0.1:8000/go")    //fmt.Println(resp)    resp, _ := http.Get("http://www.baidu.com")    defer resp.Body.Close()    // 200 OK    fmt.Println(resp.Status)    fmt.Println(resp.Header)    buf := make([]byte, 1024)    for {        // 接收服务端信息        n, err := resp.Body.Read(buf)        if err != nil &amp;&amp; err != io.EOF {            fmt.Println(err)            return        } else {            fmt.Println("读取完毕")            res := string(buf[:n])            fmt.Println(res)            break        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先我们的<code>http.Get</code>方法请求了百度的网站，查看下面函数定义知道，这个方法接受一个要访问的url，返回一个响应<code>resp</code>和错误，这个响应<code>resp</code>有什么用我们后面会看到</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func (c *Client) Get(url string) (resp *Response, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>调用者在完成阅读后应该关闭resp.Body</p></blockquote><p>这就是<code>defer resp.Body.Close()</code>的作用，每次得到<code>resp</code>后都要记得使用这代码来关闭<br><br>通过这两行代码我们可以知道，响应里记录了相应的状态、Header包头等等！</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">fmt.Println(resp.Status)fmt.Println(resp.Header)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在for循环里我们定义一个buf接受响应体的信息，其中<code>resp.Body.Read</code>函数输入参数为<code>[]byte</code>类型的切片，输出响应体的长度n和错误err，其中当读到响应体结尾时，错误为io.EOF</p><p><img src="/../assets/net_http/cli_res.png" alt="访问百度的输出结果"></p><p>我们将url换成我们自己写的服务器端的url也会得到我们想要的响应！</p><p>未完待续…</p><blockquote><p>参考资料：<br><br><a href="https://pkg.go.dev/net/http@go1.19.4">go官方文档</a><br><br><a href="https://www.topgoer.cn/docs/golang/chapter08-3">地鼠文档</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gorm基本使用</title>
      <link href="/2022/12/28/gorm-ji-ben-shi-yong/"/>
      <url>/2022/12/28/gorm-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm介绍"><a href="#Gorm介绍" class="headerlink" title="Gorm介绍"></a>Gorm介绍</h1><h2 id="什么是orm"><a href="#什么是orm" class="headerlink" title="什么是orm"></a>什么是orm</h2><p>Object-Relationl Mapping，即对象关系映射，这里的Relationl指的是关系型数据库。<br>它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。</p><h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><p>特点：</p><ul><li>全功能ORM</li><li>关联(包含一个，包含多个，属于，多对多，多种包含)</li><li>Callbacks(创建/保存/更新/删除/查找之前/之后)</li><li>预加载</li><li>事务</li><li>复合主键</li><li>SQL Builder</li><li>自动迁移</li><li>日志</li><li>可扩展，编写基于GORM回调的插件</li><li>每个功能都有测试</li><li>开发人员友好</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">go get -u gorm.io/gorm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我们后面要用gorm操作mysql，所以还要下一个mysql相关的库</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">go get -u gorm.io/driver/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://gorm.io/docs/">gorm官方文档</a></p><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {    // dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"dsn := "root:root@tcp(127.0.0.1:3306)/gorm_test?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})if err != nil {panic("数据库连接失败")}fmt.Println("数据库连接成功")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，如果要正确的处理time.Time，你需要包含parseTime参数，为了完全支持UTF-8编码，你需要将charset=utf8改为charset=utf8mb4</p></blockquote><h1 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>通过 AutoMigrate 函数可以快速建表，如果表已经存在不会重复创建。<br><br>我们先定义一个结构体，然后根据这个结构体进行建表</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">type User struct {ID           uintName         stringEmail        *stringAge          uint8Birthday     time.TimeMemberNumber sql.NullStringActivatedAt  sql.NullTimeCreatedAt    time.TimeUpdatedAt    time.Time}func main(){    dsn := "root:root@tcp(127.0.0.1:3306)/gorm_test?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})if err != nil {panic("数据库连接失败")}fmt.Println("数据库连接成功")db.AutoMigrate(&amp;User{})}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图为执行前后数据库结果<br></p><p><img src="/../assets/gorm/construt_table.png" alt="建表" title="建表"></p><h2 id="增删查改-增"><a href="#增删查改-增" class="headerlink" title="增删查改-增"></a>增删查改-增</h2><p>我们需要实例化我们创建表的结构体，Gorm会用这个结构体的参数进行增加记录<br><br>在上面代码的基础上执行下面代码会执行增加记录</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">user := User{Name: "Jinzhu", Age: 18, Birthday: time.Now()}result := db.Create(&amp;user) // pass pointer of data to Createfmt.Println(result.Error, result.RowsAffected)/* 打印结果&lt;nil&gt; 1*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看数据库发现多了我们所新增的记录！<br> <img src="/../assets/gorm/zeng1.png"></p><h2 id="增删查改-删"><a href="#增删查改-删" class="headerlink" title="增删查改-删"></a>增删查改-删</h2><p> 我们只需要用db.Delete就能删除一条记录!<br><br> 删除记录时，删除的值需要具有主键，否则将触发“批量删除”,由于gorm默认ID会被设为主键，而我们的结构体字段里正好有ID字段，因此不必再额外设置主键。但是我们当然可以自己设定主键，比如：<br> </p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang"> // 将 `UUID` 设为主键type Animal struct {  ID     int64  UUID   string `gorm:"primaryKey"`  Name   string  Age    int64}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>如果直接db.Delete删除结构体对象的话，默认是按主键删除的，我们可以使用db.Where进行条件删除<p></p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">// Email's ID is `10`db.Delete(&amp;email)// DELETE from emails where id = 10;// 指定主键进行删除db.Delete(&amp;users, []int{1,2,3})// DELETE FROM users WHERE id IN (1,2,3);// Delete with additional conditionsdb.Where("name = ?", "jinzhu").Delete(&amp;email)// DELETE from emails where id = 10 AND name = "jinzhu";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="增删查改-查"><a href="#增删查改-查" class="headerlink" title="增删查改-查"></a>增删查改-查</h2><p>查需要先声明一个结构体来接受我们的查询结果，查主要有<code>db.First</code>，<code>db.Take</code>，<code>db.Last</code>以及<code>db.Find</code>函数<br><br>我们的数据库现在又这样三条记录，让我们看看查的结果吧<br><img src="/../assets/gorm/cha1.png"></p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user User// Get the first record ordered by primary keydb.First(&amp;user)// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1fmt.Println(user) /* 打印结果{3 wlz &lt;nil&gt; 18 2022-12-28 12:45:11.353 +0800 CST { false} {0001-01-01 00:00:00 +0000 UTC false} 2022-12-28 12:45:11.353 +0800 CST 2022-12-28 12:45:11.353 +0800 CST}*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user User// Get one record, no specified orderdb.Take(&amp;user)// SELECT * FROM users LIMIT 1;fmt.Println(user) /* 打印结果{3 wlz &lt;nil&gt; 18 2022-12-28 12:45:11.353 +0800 CST { false} {0001-01-01 00:00:00 +0000 UTC false} 2022-12-28 12:45:11.353 +0800 CST 2022-12-28 12:45:11.353 +0800 CST}*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user User// Get last record, ordered by primary key descdb.Last(&amp;user)// SELECT * FROM users ORDER BY id DESC LIMIT 1;fmt.Println(user) /* 打印结果{5 Jinzhu &lt;nil&gt; 18 2022-12-28 12:48:59.916 +0800 CST { false} {0001-01-01 00:00:00 +0000 UTC false} 2022-12-28 12:48:59.916 +0800 CST 2022-12-28 12:48:59.916 +0800 CST}*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 用主键查找db.First(&amp;user, 10)// SELECT * FROM users WHERE id = 10;db.First(&amp;user, "10")// SELECT * FROM users WHERE id = 10;db.Find(&amp;users, []int{1,2,3})// SELECT * FROM users WHERE id IN (1,2,3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user User// Get all records 查找所有记录result := db.Find(&amp;users)// SELECT * FROM users;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="增删查改-改"><a href="#增删查改-改" class="headerlink" title="增删查改-改"></a>增删查改-改</h2><ol><li>先查询到对应记录，然后手动修改结构体字段值后使用<code>db.Save</code>保存<pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user Userdb.First(&amp;user)user.Name = "jinzhu 2"user.Age = 100db.Save(&amp;user)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>基于查出来的元素使用db.Model的Updates方法进行更改<pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var user Userdb.First(&amp;user)db.Model(&amp;user).Updates(map[string]interface{}{"name": "hiko", "age": 22})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>未完待续…</p><blockquote><p>参考资料：<br><br><a href="https://gorm.io/docs/">gorm官方文档</a><br><br><a href="https://zhuanlan.zhihu.com/p/113251066">Golang下的ORM框架gorm的介绍和使用</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/12/27/she-ji-mo-shi/"/>
      <url>/2022/12/27/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式思想"><a href="#设计模式思想" class="headerlink" title="设计模式思想"></a>设计模式思想</h1><p>这点在上李林老师的Linux环境高级编程课程时就深深体会到了。简单概括就是寻找变化点、封装变化点，让代码更具扩展性、维护性。</p><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p>设计模式共有26种，根据类型来分可以分为创建型模式、结构性模式、行为型模式、J2EE模式<br>具体：</p><table><thead><tr><th>模式&amp;描述</th><th>包括</th></tr></thead><tbody><tr><td>创建型模式</td><td>工厂模式<br>抽象工厂模式<br>单例模式<br>建造者模式<br>原型模式</td></tr><tr><td>结构型模式</td><td>适配器模式<br>桥接模式<br>过滤器模式<br>组合模式<br>装饰器模式<br>外观模式<br>享元模式<br>代理模式</td></tr><tr><td>行为型模式</td><td>责任链模式<br>命令模式<br>解释器模式<br>迭代器模式<br>中介者模式<br>备忘录模式<br>观察者模式<br>状态模式<br>空对象模式<br>策略模式<br>模板模式<br>访问者模式</td></tr><tr><td>J2EE模式</td><td>MVC 模式<br>业务代表模式<br>组合实体模式<br>数据访问对象模式<br>前端控制器模式<br>拦截过滤器模式<br>服务定位器模式<br>传输对象模式</td></tr></tbody></table><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其<strong>创建过程延迟到子类</strong>进行。<br><br>工厂模式其实本质上就是<code>多态</code>，创建一个基类和不同的子类，让子类继承基类并实现其自己的方法！</p><p>假设我们的业务需要一个支付渠道，我们开发了一个Pay方法，其可以用于支付。请看以下示例：</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func Pay(OrderId string) string { //OrderId订单号//todofmt.Println(OrderId)return "支付成功"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果如果我们后面又需要一种支付方式，但是需要增加用户的<code>uid</code>，明显的这两个方法逻辑上不会有太多差异，如果还用上面的方法，仅为了一个参数的差异，我们就重新定义一个函数显然不好(会有大段重复代码)。</p><p>那么这时我们可以考虑下面这样用接口的方式，定义了一个接口，接口里声明了Pay方法，并且定义了PayReq结构体实现了这个接口，那么以后我们再增加支付方式的话，我们把支付方式放在接口声明里，再在PeyReq里实现就好了！</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">type Pay interface {  Pay() string}type PayReq struct {  OrderId string // 订单号}func (p *PayReq) Pay() string {  // todo  fmt.Println(p.OrderId)  return "支付成功"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么当我们增加支付方式，比如一种叫Apay，一种叫Bpay，那么很容易想到，我们实现一个方法Apay和Bpay不就好了？</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">type Pay interface {  APay() string  BPay() string}type PayReq struct {  OrderId string // 订单号  Uid int64}func (p *PayReq) APay() string {  // todo  fmt.Println(p.OrderId)  return "APay支付成功"}func (p *PayReq) BPay() string {  // todo  fmt.Println(p.OrderId)  fmt.Println(p.Uid)  return "BPay支付成功"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们为Pay接口实现了APay() 和BPay() 方法（定义一个类，一个类里声明实现多个方法）。虽然暂时实现了业务需求，但却使得结构体PayReq变得冗余了，APay() 并不需要Uid参数。如果之后再增加CPay、DPay、EPay，可想而知，代码会变得越来越难以维护。</p><p>解决：使用我们的工厂设计模式，将创建过程延迟到子类进行（定义多个子类，在不同子类中实现其自己的方法），上面的方法种我们的创建过程在接口中也就是基类中就声明了，在下面的方法中，可以发现接口中只定义了一个Pay，而相对的我们的子类变多了，让每个子类实现自己的Pay方法！于是后面再增加支付方式，我们只需再增加一个子类来继承我们的基类（实现接口）即可！</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">package factorymethodimport "fmt"type Pay interface {  Pay(string) int}type PayReq struct {  OrderId string}type APayReq struct {  PayReq}func (p *APayReq) Pay() string {  // todo  fmt.Println(p.OrderId)  return "APay支付成功"}type BPayReq struct {  PayReq  Uid int64}func (p *BPayReq) Pay() string {  // todo  fmt.Println(p.OrderId)  fmt.Println(p.Uid)  return "BPay支付成功"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，工厂模式其实本质上就是<code>多态</code>，创建一个基类和不同的子类，让子类继承基类并实现其方法！</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>假设，有一个存储工厂，提供redis和mysql两种存储数据的方式。如果使用工厂方法模式，我们就需要一个存储工厂，并提供SaveRedis方法和SaveMysql方法。<br>如果此时业务还需要分成存储散文和古诗两种载体，这两种载体都可以进行redis和mysql存储。就可以使用抽象工厂模式，我们需要一个存储工厂作为父工厂，散文工厂和古诗工厂作为子工厂，并提供SaveRedis方法和SaveMysql方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解反射</title>
      <link href="/2022/12/27/xiang-jie-fan-she/"/>
      <url>/2022/12/27/xiang-jie-fan-she/</url>
      
        <content type="html"><![CDATA[<p>在之前的学习中，对反射总是一知半解，之前对反射的作用大概就停留在获取、设置结构体tag的值、获取结构体字段的值、属性，以及一些json的序列化和反序列化貌似也是通过反射做的？，今天花了几个小时详细的了解了一番golang中的反射，在此记录一下！</p><h2 id="反射三原则"><a href="#反射三原则" class="headerlink" title="反射三原则"></a>反射三原则</h2><p>在使用反射之前,此文<a href="https://go.dev/blog/laws-of-reflection">The Laws of Reflection</a>必读.网上中文翻译版本不少,可以搜索阅读.<br><br>三原则：</p><ul><li>Reflection goes from interface value to reflection object</li><li>Reflection goes from reflection object to interface value</li><li>To modify a reflection object, the value must be settable</li></ul><p>在三原则中,有两个关键词 interface value 与 reflection object.有点难理解,画张图可能您就懂了.<br></p><p><img src="/../assets/reflect/reflect-pic.jpg" alt="反射" title="反射"></p><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。使用反射，我们需要导入reflect包</p><ul><li><p>获取类型信息(static type)：reflect.TypeOf，是静态的</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import ("fmt""reflect")func main() {var x float64 = 3.4fmt.Println("type:", reflect.TypeOf(x))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">type: float64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们查看<code>reflect.TypeOf</code>源码，会发现其返回值是<code>Type</code>类型，这验证了我们上面所说的Type和Value</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">// TypeOf returns the reflection Type that represents the dynamic type of i.// If i is a nil interface value, TypeOf returns nil.func TypeOf(i any) Type {eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))return toType(eface.typ)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取反射的种类Kind</p></li></ul><p>什么叫Kind，在Golang中如果你定义<code>var a int32 = 5</code>，那么显然a是int32类型的，或者我们叫其<code>static type</code>为int，但是如果你定义了自定义类型</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">type Myint int32var a Myint = 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么a的<code>static type</code>是Myint也就是你显式声明的类型，而a的<code>underly type</code>是int32，也就是说a的潜在类型是int，而<code>Kind</code>方法返回的是<code>underly type</code>!</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">import ("fmt""reflect")func main() {type Myint int32var A Myint = 5typeofA := reflect.TypeOf(A)fmt.Printf("static type: %v \n", typeofA.Name())fmt.Printf("underly type: %v \n", typeofA.Kind())}/* 输出结果static type: Myintunderly type: int32 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相同的，对于结构体我们这么干得到的结果也是如我们所预期的那样</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {type A struct{}a := A{}typeofa := reflect.TypeOf(a)fmt.Printf("static type: %v \n", typeofa.Name())fmt.Printf("underly type: %v \n", typeofa.Kind())}/* 输出结果static type: Aunderly type: struct */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>获取值信息：reflect.ValueOf，是动态的</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {var x float64 = 3.4valueofX := reflect.ValueOf(x)fmt.Println("value:", valueofX)fmt.Println("value:", valueofX.String())}/* 输出结果value: 3.4value: &lt;float64 Value&gt;*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们我们显式调用String方法，因为默认情况下，fmt包会挖掘到reflect.Value，以显示内部的具体值。而String方法不会</p></li><li><p>修改值信息</p></li></ul><p>在反射中修改值信息是通过<code>SetFloat</code>、<code>SetInt</code>方法(具体方法根据具体类型而定)，但是有一些坑需要注意<br>如果我们直接使用<code>SetFloat</code>方法</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">func main() {var x float64 = 3.4v := reflect.ValueOf(x)v.SetFloat(7.1) // Error: will panic.}/* 输出结果panic: reflect: reflect.Value.SetFloat using unaddressable value*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根本原因在于，我们传入x是对x值拷贝，因此你对拷贝的值进行了修改而你以为对原来的x进行了修改，导致你对拷贝的值修改过后却没有用到他，Go当然不会允许这样的事情发生，因此panic！<br><br>我们可以通过<code>CanSet</code>方法来查看能否修改</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var x float64 = 3.4v := reflect.ValueOf(x)fmt.Println("settability of v:", v.CanSet())/* 结果settability of v: false*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确做法：传入x的地址，并调用Elem方法解引用！</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">var x float64 = 3.4p := reflect.ValueOf(&amp;x) // Note: take the address of x.v := p.Elem()v.SetFloat(6.9)fmt.Println("settability of v:", v.CanSet())fmt.Println("value of x: ", x)/* 输出结果settability of v: truevalue of x:  6.9*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们修改值信息必须知道对应的类型来调用对应的方法，因此我们通常可以配和使用switch来实现</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">//反射修改值func reflect_set_value(a interface{}) {    v := reflect.ValueOf(a)    k := v.Kind()    switch k {    case reflect.Float64:        // 反射修改值        v.SetFloat(6.9)        fmt.Println("a is ", v.Float())    case reflect.Ptr:        // Elem()获取地址指向的值        v.Elem().SetFloat(7.9)        fmt.Println("case:", v.Elem().Float())        // 地址        fmt.Println(v.Pointer())    }}func main() {    var x float64 = 3.4    // 反射认为下面是指针类型，不是float类型    reflect_set_value(&amp;x)    fmt.Println("main:", x)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反射与结构体"><a href="#反射与结构体" class="headerlink" title="反射与结构体"></a>反射与结构体</h2><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。</p><h3 id="查看结构体类型、字段、方法"><a href="#查看结构体类型、字段、方法" class="headerlink" title="查看结构体类型、字段、方法"></a>查看结构体类型、字段、方法</h3><p>我们可以根据<code>NumField</code>方法得到结构体有多少个字从而进行遍历，通过<code>Field</code>方法得到具体的某个字段，通过<code>NUmMethod</code>得到结构体有多少个方法，通过<code>Method</code>方法得到具体的某个方法</p><pre class="line-numbers language-Golang" data-language="Golang"><code class="language-Golang">// 定义结构体type User struct {Id   intName stringAge  int}// 绑方法func (u User) Hello() {fmt.Println("Hello")}// 传入interface{}func Poni(o interface{}) {t := reflect.TypeOf(o)fmt.Println("类型：", t)fmt.Println("字符串类型：", t.Name())// 获取值v := reflect.ValueOf(o)fmt.Println(v)// 可以获取所有属性// 获取结构体字段个数：t.NumField()for i := 0; i &lt; t.NumField(); i++ {// 取每个字段f := t.Field(i)fmt.Printf("%s : %v", f.Name, f.Type)// 获取字段的值信息// Interface()：获取字段对应的值val := v.Field(i).Interface()fmt.Println("val :", val)}fmt.Println("=================方法====================")for i := 0; i &lt; t.NumMethod(); i++ {m := t.Method(i)fmt.Println(m.Name)fmt.Println(m.Type)}}func main() {u := User{1, "zs", 20}Poni(u)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未完待续…</p><blockquote><p><a href="https://go.dev/blog/laws-of-reflection">The Laws of Reflection</a><br><br><a href="https://www.topgoer.cn/docs/golang/chapter11-12">反射(地鼠文档)</a><br><br><a href="https://pkg.go.dev/reflect@go1.19.4#pkg-overview">reflect(go官方文档)</a><br><br><a href="https://zhuanlan.zhihu.com/p/411313885">一篇带你全面掌握go反射的用法</a><br><br><a href="http://c.biancheng.net/view/4407.html">Go语言反射（reflection）简述</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建自己的个人博客</title>
      <link href="/2022/12/23/hexo-da-jian-zi-ji-de-ge-ren-bo-ke/"/>
      <url>/2022/12/23/hexo-da-jian-zi-ji-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo下载"><a href="#hexo下载" class="headerlink" title="hexo下载"></a>hexo下载</h2><h3 id="node-js和cnpm下载"><a href="#node-js和cnpm下载" class="headerlink" title="node.js和cnpm下载"></a>node.js和cnpm下载</h3><p>因为hexo是依赖于node.js的，因此我们需要先下载node.js(<a href="nodejs.org">node.js下载地址</a>)。<br>node.js安装过程就一路next即可<br><br>我们使用<code>node -v</code>来查看node.js是否安装成功</p><p><img src="/../assets/nodejs-v.png"></p><p>下载完node.js我们再来进行一下简单的配置，具体可以参见<a href="https://zhuanlan.zhihu.com/p/442215189">这篇博客</a></p><p>下载完node.js一般会自动帮你把npm下载好同样的我们使用<code>npm-v</code>查看是否安装<br><img src="/../assets/npm-v.png"></p><p>然后我们接着用淘宝源下载cnmp：</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry=https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样用<code>cnpm -v</code>查看是否安装成功<br><img src="/../assets/cnpm-v.png"></p><h3 id="hexo下载-1"><a href="#hexo下载-1" class="headerlink" title="hexo下载"></a>hexo下载</h3><p>终于到了下载hexo了，执行下面命令下载：</p><pre class="line-numbers language-none"><code class="language-none">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看是否安装成功：</p><p><img src="/../assets/hexo-v.png"></p><p>接下来我们创建一个空目录叫Blog(里面会装所有我们的博客内容、配置、样式等)，我这里在D盘创建了。然后跳转到这个目录，执行<code>hexo init</code></p><p><img src="/../assets/hexo-init.png"></p><p>然后目录里就会自动生成这么多文件:</p><p><img src="/../assets/hexo-init-dir.png"></p><p>接下来我们执行<code>hexo s</code>表示start，</p><p><img src="/../assets/hexo-s.png"></p><p>显示运行在4000端口，那我们打开4000端口，会出现这样一个系统默认自带的一个博客页面</p><p><img src="/../assets/hexo-s-4000.png"></p><p>也可以看到里面有四条简单的入门指令</p><h2 id="hexo新建文章"><a href="#hexo新建文章" class="headerlink" title="hexo新建文章"></a>hexo新建文章</h2><p>接下来到了我们的重点，我们使用<code>hexo n</code>(hexo new的简写) 来新建一篇博客</p><p><img src="/../assets/hexo-n.png"></p><p>接下来我们跳转到<code>source\_posts</code>目录下可以看到<code>我的第一篇博客.md</code><br>接下来，我们就可以打开这个md文件(Vscode或者记事本等等，linux还可以用vim)进行编辑来达到写博客的效果。<br><br>编写完博客后我们分别执行<code>hexo clean</code>删除缓存文件和<code>hexo generate</code>生成静态文件</p><p><img src="/../assets/hexo-clean-generate.png"></p><p>然后我们再执行<code>hexo s</code>在本地看看效果吧：<br>不出意外，你应该可以看到你新建的那篇博客！</p><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>首先我们先登录我们的github新建一个名为<code>username.github.io</code>的仓库(其中username为你自己的用户名)，千万注意这个仓库名只能是这个，一个字符都不能错！！！<br></p><p>创建完后当前仓库还是空的，我们先下载一个hexo-deployer-git包:</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进行一些关键配置：<br>进入Blog目录找到_config.yml并打开，将type后面填入git(单引号别删，mac系统貌似本来就没有单引号)，然后在下面添加两行repo和branch，repo填入自己刚刚创建好的那个github仓库地址(.git后缀)，branch就填master就好(注意冒号后面加空格哦)</p><p><img src="/../assets/hexo-config.png"></p><p>配置好后直接<code>hexo d</code>就开始部署了！（如果你之前没对github做什么配置的话应该是要输入github用户名和密码的）<br></p><p>部署好了之后，打开刚才新建的仓库，会发现仓库有东西了！</p><p><img src="/../assets/hexo-d-repo.png"></p><p>这时我们打开<code>username.github.io</code>(其中username为你的github用户名)，你会发现你的博客出现了！（可能没那么快，等个半分钟左右就会出现），至此已经完成了搭建个人笔记网站及部署！</p><h2 id="博客样式更改"><a href="#博客样式更改" class="headerlink" title="博客样式更改"></a>博客样式更改</h2><p>克隆<code>https://github.com/litten/hexo-theme-yilia</code>这个仓库到你的Blog目录下的themes目录下，名称可以取为yilia</p><p><img src="/../assets/yilia-down.png"></p><p>然后再打开Blog下的<code>_config.yml</code>将其中的theme后的内容改成yilia，然后我们继续<code>hexo clean'和'hexo generate</code>和<code>hexo d</code>在刷新我们的个人博客即可出现更新后的样式！</p><p>详细配置修改：<br>进入yilia目录，打开其中的<code>_config.yml</code>修改其中的配置！比如我要上传自己的头像，我就在public目录下创建assets目录再创建img目录，其中放入我的头像，然后在yilia目录里的_config.yml文件里先将我的根目录改为：<code>root: /themes/yilia/source/</code>，再将头像url改为：<code>avatar: /assets/img/me.jpg</code></p><p><img src="/../assets/img_upload.png"></p><p>然后再重复<code>hexo clean'和'hexo generate</code>和<code>hexo d</code>在刷新我们的个人博客即可出现更新后的样式！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=6f8003c7f384d9ec853a735c71e66571">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 博客相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/23/hello-world/"/>
      <url>/2022/12/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
